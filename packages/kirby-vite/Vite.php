<?php declare(strict_types=1);

namespace arnoson\KirbyVite;
use Kirby\Filesystem\F;
use \Exception;
use Kirby\Cms\App;

class Vite {
  protected static Vite $instance;
  protected bool $hasClient = false;
  protected bool $hasLegacyPolyfills = false;
  protected ?bool $isDev = null;
  protected ?string $outDir = null;
  protected ?array $manifest = null;
  protected ?array $config = null;

  public static function getInstance(): Vite {
    return self::$instance ??= new self();
  }

  /**
   * Read `vite.config.php`, generated by vite-plugin-kirby.
   */
  protected function config(): array {
    return $this->config ??= require kirby()->root('config') .
      '/vite.config.php';
  }

  protected function getRelativePath(string $rootPath, string $fullPath): ?string {
    $rootPath = realpath(rtrim($rootPath, '/'));
    $fullPath = realpath(rtrim($fullPath, '/'));
  
    if (str_starts_with($fullPath, $rootPath)) {
      return ltrim(substr($fullPath, strlen($rootPath)), DIRECTORY_SEPARATOR);
    }
  
    return null;
  }  

  /**
   * Get Vite's `outDir`, but relative to Kirby's index root. This is important
   * for public folder setups, where Kirby's index is not the project root. In
   * this case (where `public` is the index) `public/dist` would become `dist`.
   */
  protected function outDir(): string {
    return $this->outDir ??= kirby()->root('base')
      ? $this->getRelativePath(
        kirby()->root('index'),
        kirby()->root('base') . '/' . $this->config()['outDir']
      )
      : $this->config()['outDir'];
  }

  protected function baseDir(): string {
    return kirby()->root('base') ?? kirby()->root('index');
  }

  /**
   * Check if we're in development mode.
   */
  protected function isDev(): bool {
    return $this->isDev ??= F::exists($this->baseDir() . '/.dev');;
  }

  protected function isStyle(string $entry): bool {
    $extension = F::extension($entry);
    return in_array(
      $extension,
      ['css', 'scss', 'sass', 'less', 'styl', 'stylus'],
      true
    );
  }

  /**
   * Read vite's dev server from the `.dev` file.
   *
   * @throws Exception
   */
  protected function server(): string {
    $devDir = kirby()->root('base') ?? kirby()->root('index');
    $dev = F::read("$devDir/.dev");

    [$key, $value] = explode('=', trim($dev), 2);
    if ($key !== 'VITE_SERVER' && option('debug')) {
      throw new Exception('VITE_SERVER not found in `.dev` file.');
    }

    return $value;
  }

  /**
   * Read and parse the manifest file.
   *
   * @throws Exception
   */
  public function manifest(): array {
    if (isset($this->manifest)) {
      return $this->manifest;
    }

    $index = kirby()->root('index');
    $outDir = $this->outDir();
    $manifest = $this->config()['manifest'];
    $manifestPath = "$index/$outDir/$manifest";

    if (!F::exists($manifestPath)) {
      if (option('debug')) {
        throw new Exception('`manifest.json` not found.');
      }
      return [];
    }

    return $this->manifest = json_decode(F::read($manifestPath), true);
  }

  /**
   * Get the value of a manifest property for a specific entry.
   *
   * @throws Exception
   */
  protected function manifestProperty(
    string $entry,
    string $key = 'file',
    bool $try = false
  ): null|string|array {
    $manifestEntry = $this->manifest()[$entry] ?? null;
    if (!$manifestEntry) {
      if (!$try && option('debug')) {
        throw new Exception("`$entry` is not a manifest entry.");
      }
      return null;
    }

    $value = $manifestEntry[$key] ?? null;
    if (!$value) {
      if (!$try && option('debug')) {
        throw new Exception("`$key` not found in manifest entry `$entry`");
      }
      return null;
    }

    return $value;
  }

  /**
   * Get the url for the specified file for development mode.
   */
  protected function assetDev(string $file): string {
    return $this->server() . "/$file";
  }

  /**
   * Get the URL for the specified file for production mode.
   */
  protected function assetProd(string $file): string {
    $outDir = $this->outDir();
    return "/$outDir/$file";
  }

  protected function client(): ?string {
    return js($this->assetDev('@vite/client'), ['type' => 'module']);
  }

  public function panelJs(?string $entry = null): string|array|null {
    if (App::version() < 4) {
      if (option('debug')) {
        throw new Exception('`vite()->panelJs()` requires Kirby 4');
      }
      return null;
    }

    if (!$entry) {
      return $this->isDev() ? '@vite/client' : null;
    }
    $asset = $this->file($entry);
    $asset = ltrim($asset, '/');
    return $this->isDev() ? ['@vite/client', $asset] : $asset;
  }

  public function panelCss($entry) {
    if (App::version() < 4) {
      if (option('debug')) {
        throw new Exception('`vite()->panelCss()` requires Kirby 4');
      }
      return null;
    }

    $entryIsStyle = $this->isStyle($entry);
    if ($this->isDev()) {
      return $entryIsStyle ? $this->assetDev($entry) : null;
    }

    $file = null;
    if ($entryIsStyle) {
      $file = $this->manifestProperty($entry, 'file');
    } else {
      $css = $this->manifestProperty($entry, 'css');
      $file = $css ? $css[0] : null;
    }
    if (!$file) {
      return null;
    }

    $asset = $this->assetProd($file);
    return ltrim($asset, '/');
  }

  /**
   * Include the js file for the specified entry.
   */
  public function js(
    string $entry,
    array $options = [],
    bool $try = false
  ): ?string {
    $file = $this->file($entry, $try);
    if (!$file && $try) {
      return null;
    }

    $options = array_merge(['type' => 'module'], $options);
    $tags = [];

    // Client is only needed during development.
    if ($this->isDev() && !$this->hasClient) {
      array_push($tags, $this->client());
      $this->hasClient = true;
    }
    
    // Legacy code is only needed in production.
    $legacy = !$this->isDev() && $this->config()['legacy'];
    if ($legacy && !$this->hasLegacyPolyfills) {
      array_push($tags, $this->legacyPolyfills());
      $this->hasLegacyPolyfills = true;
    }
    if ($legacy) {
      array_push($tags, $this->legacyJs($entry));
    }

    // Finally, add the entry itself.
    array_push($tags, js($file, $options));
    return implode("\n", array_filter($tags));
  }

  /**
   * Include the css file for the specified entry in production mode. Your CSS
   * file can either be CSS entry `vite()->css('main.css')` or a js entry
   * `vite()->css('main.js')`, in this case the CSS imported in the JS file will
   *  be used.
   */
  public function css(
    string $entry,
    array $options = [],
    bool $try = false
  ): ?string {
    $tags = [];

    // Client is only needed during development.
    if ($this->isDev() && !$this->hasClient) {
      array_push($tags, $this->client());
      $this->hasClient = true;
    }

    $entryIsStyle = $this->isStyle($entry);
    // During development, we only have to include the style if it is
    // 'standalone', meaning a css (or sass, ...) file. The css for an js entry
    // like `vite()->css('entry.js')` will be injected automatically.
    if ($this->isDev() && $entryIsStyle) {
      array_push($tags, css($this->assetDev($entry), $options));
    }

    // If the entry is a css file we can simply add it...
    if (!$this->isDev() && $entryIsStyle) {
      $file = $this->manifestProperty($entry, 'file', $try);
      if ($file) array_push($tags, css($this->assetProd($file), $options));
    }
    // ...but if it is a js file we have to look up the manifest and add all
    // css files associated with the entry and it's imports. 
    if (!$this->isDev() && !$entryIsStyle) {
      $cssList = $this->manifestProperty($entry, 'css', $try) ?? [];
      foreach ($cssList as $css) {
        array_push($tags, css($this->assetProd($css), $options));
      }
      array_push($tags, ...$this->collectImportCss($entry, $options));
    }

    return count($tags) ? implode("\n", $tags) : null;
  }

  /**
   * Recursively collect all the css of the manifest item and it's imports.
   */
  protected function collectImportCss(string $key, array $options = []): array {
    $imports = $this->manifestProperty($key, 'imports', true) ?? [];
    $tags = [];
    foreach ($imports as $import) {
      $cssList = $this->manifestProperty($import, 'css', true) ?? [];
      foreach ($cssList as $css) {
        array_push($tags, css($this->assetProd($css), $options));
      }
      array_push($tags, ...$this->collectImportCss($import, $options));
    }
    return $tags;
  }

  /**
   * Return manifest file path for entry.
   */
  public function file(string $entry, bool $try = false): ?string {
    if ($this->isDev()) {
      return $this->assetDev($entry);
    }

    $property = $this->manifestProperty($entry, 'file', $try);
    return $property ? $this->assetProd($property) : null;
  }

  protected function legacyPolyfills(array $options = []): ?string {
    $entry = null;
    foreach (array_keys($this->manifest()) as $key) {
      // The legacy entry is relative from vite's root folder (e.g.:
      // `../vite/legacy-polyfills-legacy`). To handle all cases we just check
      // for the ending.
      if (str_ends_with($key, 'vite/legacy-polyfills-legacy')) {
        $entry = $key;
        break;
      }
    }

    // Polyfills entry is only generated if any polyfills are used.
    if (!$entry) {
      return null;
    }

    return js($entry, array_merge(['nomodule' => true], $options));
  }

  protected function legacyJs(
    string $entry,
    array $options = [],
    bool $try = false
  ): ?string {
    $parts = explode('.', $entry);
    $parts[count($parts) - 2] .= '-legacy';
    $legacyEntry = join('.', $parts);
    $file = $this->file($legacyEntry, $try);
    if (!$file) {
      return null;
    }
    return js($file, array_merge(['nomodule' => true], $options));
  }
}
