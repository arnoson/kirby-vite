<?php declare(strict_types=1);

namespace arnoson\KirbyVite;
use Kirby\Filesystem\F;
use \Exception;
use Kirby\Cms\App;
use Kirby\Toolkit\A;
use Kirby\Toolkit\Str;

class Vite {
  protected static Vite $instance;
  protected bool $hasClient = false;
  protected bool $hasLegacyPolyfills = false;
  protected ?bool $isDev = null;
  protected ?string $outDir = null;
  protected ?string $rootDir = null;
  protected ?string $server = null;
  protected ?array $manifest = null;
  protected ?array $config = null;

  public static function getInstance(): Vite {
    return self::$instance ??= new self();
  }

  public function isDev(): bool {
    return $this->isDev ??= F::exists($this->baseDir() . '/.dev');
  }

  protected function isStyle(string $entry): bool {
    $extension = F::extension($entry);
    return in_array(
      $extension,
      ['css', 'scss', 'sass', 'less', 'styl', 'stylus'],
      true
    );
  }

  protected function exists(string $entry) {
    return $this->isDev()
      ? F::exists($this->rootDir() . '/' . $entry)
      : !!$this->manifestProperty($entry, try: true);
  }

  protected function getRelativePath(
    string $rootPath,
    string $fullPath
  ): ?string {
    $rootPath = realpath(rtrim($rootPath, '/'));
    $fullPath = realpath(rtrim($fullPath, '/'));

    if (str_starts_with($fullPath, $rootPath)) {
      return ltrim(substr($fullPath, strlen($rootPath)), DIRECTORY_SEPARATOR);
    }

    return null;
  }

  protected function resolveEntry(string $entry): string {
    return Str::template($entry, [
      'kirby' => ($kirby = kirby()),
      'site' => ($site = $kirby->site()),
      'page' => $site->page(),
    ]);
  }

  /**
   * Read `vite.config.php`, generated by vite-plugin-kirby.
   */
  protected function config(): array {
    return $this->config ??= require kirby()->root('config') .
      '/vite.config.php';
  }

  /**
   * Get Vite's `outDir` relative to Kirby's index root.
   */
  protected function outDir(): string {
    return $this->outDir ??= kirby()->root('base')
      ? $this->getRelativePath(
        kirby()->root('index'),
        kirby()->root('base') . '/' . $this->config()['outDir']
      )
      : $this->config()['outDir'];
  }

  protected function baseDir(): string {
    return kirby()->root('base') ?? kirby()->root('index');
  }

  protected function rootDir(): string {
    return $this->rootDir ??=
      $this->config()['rootDir'] ?? null
        ? $this->baseDir() . '/' . $this->config()['rootDir']
        : $this->baseDir();
  }

  /**
   * Read vite's dev server from the `.dev` file.
   *
   * @throws Exception
   */
  protected function server(): string {
    if (isset($server)) {
      return $server;
    }

    $devDir = kirby()->root('base') ?? kirby()->root('index');
    $dev = F::read("$devDir/.dev");

    [$key, $value] = explode('=', trim($dev), 2);
    if ($key !== 'VITE_SERVER' && option('debug')) {
      throw new Exception('VITE_SERVER not found in `.dev` file.');
    }

    return $this->server = $value;
  }

  /**
   * Read and parse the manifest file.
   *
   * @throws Exception
   */
  public function manifest(): array {
    if (isset($this->manifest)) {
      return $this->manifest;
    }

    $index = kirby()->root('index');
    $outDir = $this->outDir();
    $manifest = $this->config()['manifest'] ?? '.vite/manifest.json';
    $manifestPath = "$index/$outDir/$manifest";

    if (!F::exists($manifestPath)) {
      if (option('debug')) {
        throw new Exception('`manifest.json` not found.');
      }
      return [];
    }

    return $this->manifest = json_decode(F::read($manifestPath), true);
  }

  /**
   * Get the value of a manifest property for a specific entry.
   *
   * @throws Exception
   */
  protected function manifestProperty(
    string $entry,
    string $key = 'file',
    bool $try = false
  ): null|string|array {
    $manifestEntry = $this->manifest()[$entry] ?? null;
    if (!$manifestEntry) {
      if (!$try && option('debug')) {
        throw new Exception("`$entry` is not a manifest entry.");
      }
      return null;
    }

    $value = $manifestEntry[$key] ?? null;
    if (!$value) {
      if (!$try && option('debug')) {
        throw new Exception("`$key` not found in manifest entry `$entry`");
      }
      return null;
    }

    return $value;
  }

  protected function client(): ?string {
    return js($this->assetDev('@vite/client'), ['type' => 'module']);
  }

  protected function assetDev(string $file): string {
    return $this->server() . "/$file";
  }

  protected function assetProd(string $file): string {
    return '/' . $this->outDir() . "/$file";
  }

  /**
   * Return the correct path for the entry, depending on whether we're in
   * development or production.
   */
  public function file(
    string $entry,
    bool $try = false,
    $resolveQuery = true
  ): ?string {
    if ($resolveQuery) {
      $entry = $this->resolveEntry($entry);
    }

    if ($this->isDev()) {
      return $this->assetDev($entry);
    }

    $property = $this->manifestProperty($entry, 'file', $try);
    return $property ? $this->assetProd($property) : null;
  }

  /**
   * Include the js file for the specified entry.
   */
  public function js(
    string $entry,
    array $options = [],
    bool $try = false
  ): ?string {
    $entry = $this->resolveEntry($entry);

    $options = array_merge(['type' => 'module'], $options);
    $tags = [];

    // Client is only needed during development.
    if ($this->isDev() && !$this->hasClient) {
      array_push($tags, $this->client());
      $this->hasClient = true;
    }

    // Legacy code is only needed in production.
    $legacy = !$this->isDev() && $this->config()['legacy'];
    if ($legacy && !$this->hasLegacyPolyfills) {
      array_push($tags, $this->legacyPolyfills());
      $this->hasLegacyPolyfills = true;
    }
    if ($legacy) {
      array_push($tags, $this->legacyJs($entry));
    }

    // Finally, add the entry itself.
    if (!$try || $this->exists($entry)) {
      $file = $this->file($entry, $try, false);
      array_push($tags, js($file, $options));
    }

    return implode("\n", array_filter($tags));
  }

  /**
   * Include the css file for the specified entry in production mode. Your css
   * file can either be css entry `vite()->css('main.css')` or a js entry
   * `vite()->css('main.js')`, in this case the css imported in the js file will
   *  be used.
   */
  public function css(
    string $entry,
    array $options = [],
    bool $try = false
  ): ?string {
    $entry = $this->resolveEntry($entry);

    $isStyle = $this->isStyle($entry);
    $tags = [];

    // Client is only needed during development.
    if ($this->isDev() && !$this->hasClient) {
      array_push($tags, $this->client());
      $this->hasClient = true;
    }

    if ($isStyle && (!$try || $this->exists($entry))) {
      $file = $this->file($entry, $try, false);
      array_push($tags, css($file, $options));
    }

    // The css for a js entry will be injected automatically in development,
    // so we only have to handle production.
    if (!$isStyle && !$this->isDev()) {
      $cssList = $this->manifestProperty($entry, 'css', $try) ?? [];
      foreach ($cssList as $css) {
        array_push($tags, css($this->assetProd($css), $options));
      }
      foreach ($this->collectImportCss($entry, $options) as $css) {
        array_push($tags, css($css, $options));
      }
    }

    return count($tags) ? implode("\n", $tags) : null;
  }

  /**
   * Recursively collect all the css of the manifest item and it's imports.
   */
  protected function collectImportCss(string $key): array {
    $imports = $this->manifestProperty($key, 'imports', true) ?? [];
    $tags = [];
    foreach ($imports as $import) {
      $cssList = $this->manifestProperty($import, 'css', true) ?? [];
      foreach ($cssList as $css) {
        array_push($tags, $this->assetProd($css));
      }
      array_push($tags, ...$this->collectImportCss($import));
    }
    return $tags;
  }

  public function panelJs(string|array $entries = []): array|null {
    if (App::version() < 4) {
      if (option('debug')) {
        throw new Exception('`vite()->panelJs()` requires Kirby 4');
      }
      return null;
    }

    $files = [];

    if ($this->isDev()) {
      array_push($files, '@vite/client');
    }

    foreach (A::wrap($entries) as $entry) {
      $file = ltrim($this->file($entry), '/');
      array_push($files, $file);
    }

    return count($files) ? $files : null;
  }

  public function panelCss(string|array $entries = []): array|null {
    if (App::version() < 4) {
      if (option('debug')) {
        throw new Exception('`vite()->panelCss()` requires Kirby 4');
      }
      return null;
    }

    $files = [];

    foreach (A::wrap($entries) as $entry) {
      $isStyle = $this->isStyle($entry);
      if ($isStyle) {
        $file = ltrim($this->file($entry), '/');
        array_push($files, $file);
        continue;
      }
      // The css for an js entry will be injected automatically in development,
      // so only have to handle production.
      if (!$isStyle && !$this->isDev()) {
        $cssList = $this->manifestProperty($entry, 'css', true) ?? [];
        foreach ($cssList as $css) {
          $file = ltrim($this->assetProd($css), '/');
          array_push($files, $file);
        }
        foreach ($this->collectImportCss($entry) as $css) {
          array_push($files, ltrim($css, '/'));
        }
      }
    }

    return count($files) ? $files : null;
  }

  protected function legacyPolyfills(array $options = []): ?string {
    $entry = null;
    foreach (array_keys($this->manifest()) as $key) {
      // The legacy entry is relative from vite's root folder (e.g.:
      // `../vite/legacy-polyfills-legacy`). To handle all cases we just check
      // for the ending.
      if (str_ends_with($key, 'vite/legacy-polyfills-legacy')) {
        $entry = $key;
        break;
      }
    }

    // Polyfills entry is only generated if any polyfills are used.
    if (!$entry) {
      return null;
    }

    return js($entry, array_merge(['nomodule' => true], $options));
  }

  protected function legacyJs(
    string $entry,
    array $options = [],
    bool $try = false
  ): ?string {
    $entry = $this->resolveEntry($entry);
    $parts = explode('.', $entry);
    $parts[count($parts) - 2] .= '-legacy';
    $legacyEntry = join('.', $parts);
    $file = $this->file($legacyEntry, $try, false);
    if (!$file) {
      return null;
    }
    return js($file, array_merge(['nomodule' => true], $options));
  }
}
